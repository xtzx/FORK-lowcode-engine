# 低代码引擎多层架构设计分析

## 一、架构层级概览

低代码引擎的渲染架构共分为以下几层：

```
DesignerView (设计器视图层)
    ↓
ProjectView (项目视图层)
    ↓
BuiltinSimulatorHostView (模拟器视图层)
    ↓
BuiltinSimulatorHost (模拟器主机层)
    ↓
SimulatorRenderer (渲染器层)
```

## 二、各层详细分析

### 1. Project 层（数据管理层）

#### 主要职责
- **项目级数据管理**：管理整个项目的 Schema、组件映射、国际化等数据
- **多文档管理**：支持同时管理多个页面文档
- **生命周期管理**：协调模拟器和渲染器的初始化时机

#### 核心功能
```javascript
class Project {
  // 文档管理
  documents: IDocumentModel[]        // 所有文档列表
  currentDocument                   // 当前激活文档
  createDocument()                   // 创建新文档
  open()                            // 打开文档

  // 数据管理
  componentsMap                      // 组件映射表
  i18n                              // 国际化配置
  config                            // 项目配置

  // 模拟器管理
  simulator: ISimulatorHost         // 模拟器实例
  mountSimulator()                  // 挂载模拟器

  // 事件通知
  onCurrentDocumentChange()         // 文档切换事件
  onSimulatorReady()               // 模拟器就绪事件
  onRendererReady()                // 渲染器就绪事件
}
```

#### 为什么必要？
- **数据中心**：作为整个设计器的数据中心，管理所有文档和配置
- **多文档支持**：企业级应用需要同时编辑多个页面
- **状态共享**：在不同文档间共享组件库、国际化等资源

### 2. ProjectView 层（项目视图层）

#### 主要职责
- **视图容器**：作为项目的视图容器，管理 Loading 和 Simulator 组件
- **生命周期协调**：监听渲染器就绪事件，控制 Loading 显示

#### 核心功能
```jsx
class ProjectView extends Component {
  componentDidMount() {
    // 监听渲染器就绪
    project.onRendererReady(() => {
      this.forceUpdate();  // 隐藏 Loading，显示内容
    });
  }

  render() {
    return (
      <div className="lc-project">
        <div className="lc-simulator-shell">
          {/* 条件渲染 Loading */}
          {!project?.simulator?.renderer && <Loading />}
          {/* 渲染模拟器 */}
          <Simulator {...simulatorProps} />
        </div>
      </div>
    );
  }
}
```

#### 为什么必要？
- **加载状态管理**：统一管理项目的加载状态
- **模拟器切换**：支持切换不同的模拟器实现（如移动端、PC端）
- **扩展点**：提供项目级的 UI 扩展能力

### 3. BuiltinSimulatorHostView 层（模拟器视图层）

#### 主要职责
- **UI 结构管理**：管理 Canvas、Viewport、Content 等 UI 结构
- **设备模拟**：通过 CSS 类和样式模拟不同设备外观
- **视觉层级**：管理 BemTools（辅助工具）、iframe 等视觉层级

#### 核心功能
```jsx
class BuiltinSimulatorHostView extends Component {
  constructor(props) {
    // 创建或获取 host 实例
    this.host = project.simulator || new BuiltinSimulatorHost(project);
    this.host.setProps(this.props);
  }

  render() {
    return (
      <div className="lc-simulator">
        <Canvas host={this.host}>
          <Viewport>
            <BemTools />     {/* 辅助工具层 */}
            <Content>        {/* 内容层 */}
              <iframe />     {/* 实际渲染的 iframe */}
            </Content>
          </Viewport>
        </Canvas>
      </div>
    );
  }
}
```

#### UI 层级结构
```
Simulator (模拟器容器)
  └── Canvas (设备外壳，如 iPhone 外观)
      └── Viewport (视口，控制缩放和定位)
          ├── BemTools (辅助工具，如参考线、标尺)
          └── Content (内容容器)
              └── iframe (隔离的渲染环境)
```

#### 为什么必要？
- **设备模拟**：提供真实的设备预览体验
- **视觉辅助**：集成标尺、参考线等设计辅助工具
- **响应式预览**：支持不同分辨率和缩放比例的预览

### 4. BuiltinSimulatorHost 层（模拟器主机层）

#### 主要职责
- **iframe 管理**：创建和管理 iframe，注入依赖和资源
- **事件处理**：处理拖拽、选择、编辑等交互事件
- **资源管理**：管理组件库、主题、环境变量等资源
- **通信桥梁**：作为设计器和渲染器之间的通信桥梁

#### 核心功能
```javascript
class BuiltinSimulatorHost {
  // iframe 管理
  mountContentFrame(iframe)         // 挂载 iframe
  _contentWindow                    // iframe 的 window 对象
  _contentDocument                  // iframe 的 document 对象

  // 资源管理
  buildLibrary()                    // 构建组件库资源
  componentsConsumer               // 组件消费者
  injectionConsumer               // 注入消费者

  // 事件处理
  setupEvents()                    // 设置所有事件监听
  setupDragAndClick()             // 拖拽和点击事件
  setupDetecting()                // 元素检测
  setupLiveEditing()              // 实时编辑

  // 视口管理
  viewport: Viewport              // 视口控制（缩放、滚动）
  scroller: IScroller            // 滚动控制

  // 配置管理
  device                         // 设备类型
  locale                        // 语言设置
  designMode                    // 设计模式（design/preview/live）
  renderEnv                     // 渲染环境
}
```

#### 关键方法：mountContentFrame
```javascript
async mountContentFrame(iframe) {
  // 1. 保存 iframe 引用
  this._iframe = iframe;
  this._contentWindow = iframe.contentWindow;

  // 2. 构建资源列表
  const vendors = [
    environment,     // React/Vue 等运行环境
    library,        // 组件库
    theme,          // 主题样式
    simulatorUrl    // 渲染器代码
  ];

  // 3. 创建模拟器（注入资源到 iframe）
  const renderer = await createSimulator(this, iframe, vendors);

  // 4. 等待依赖就绪
  await this.componentsConsumer.waitFirstConsume();
  await this.injectionConsumer.waitFirstConsume();

  // 5. 开始渲染
  renderer.run();

  // 6. 设置事件监听
  this.setupEvents();
}
```

#### 为什么必要？
- **隔离环境**：iframe 提供完全隔离的运行环境，避免样式和脚本冲突
- **事件管理**：统一管理设计态的所有交互事件
- **资源编排**：按正确顺序加载和初始化所有资源
- **状态同步**：在设计器和渲染器之间同步状态

### 5. SimulatorRenderer 层（渲染器层）

#### 主要职责
- **Schema 渲染**：将 Schema 转换为实际的 React/Vue 组件
- **组件管理**：管理运行时的组件实例
- **数据流管理**：处理组件间的数据流和状态管理

#### 为什么必要？
- **运行时隔离**：在 iframe 内独立运行，与设计器隔离
- **框架适配**：支持不同的前端框架（React、Vue等）

## 三、层级设计的必要性分析

### 必不可少的层级

#### 1. Project + Host 组合（核心数据和运行时）
- **Project**：管理数据，不可缺少
- **Host**：管理 iframe 和事件，不可缺少
- 这两层是整个架构的核心，缺一不可

#### 2. SimulatorRenderer（渲染执行层）
- 在 iframe 内执行实际渲染
- 与设计器完全隔离
- 不可缺少

### 可以优化的层级

#### 1. ProjectView 层
- **可以合并到 DesignerView**：如果不需要复杂的项目级 UI 管理
- **保留的理由**：
  - 支持多项目切换
  - 统一的 Loading 管理
  - 项目级的 UI 扩展

#### 2. HostView 层
- **可以合并到 Host**：如果不需要复杂的 UI 结构
- **保留的理由**：
  - 清晰的 UI 结构分层（Canvas、Viewport、Content）
  - 设备外观模拟
  - 辅助工具集成（BemTools）

## 四、设计模式和原则

### 1. 关注点分离（SoC）
- **数据层**（Project）：只管理数据
- **视图层**（ProjectView、HostView）：只负责 UI 渲染
- **业务层**（Host）：处理业务逻辑和事件
- **运行层**（Renderer）：执行实际渲染

### 2. 单一职责原则（SRP）
每一层都有明确的单一职责：
- Project：项目数据管理
- ProjectView：项目视图容器
- HostView：模拟器 UI 结构
- Host：iframe 和事件管理
- Renderer：Schema 渲染

### 3. 依赖倒置原则（DIP）
- 上层不依赖下层的具体实现
- 通过接口（ISimulatorHost、IProject）定义契约
- 支持替换不同的实现（如不同的 Simulator）

## 五、常见坑点和注意事项

### 1. 生命周期问题
```javascript
// 错误：直接访问 renderer
if (project.simulator.renderer) { // 可能为 undefined
  doSomething();
}

// 正确：等待就绪事件
project.onRendererReady(() => {
  doSomething();
});
```

### 2. iframe 通信问题
- **跨域限制**：iframe 必须同域或设置适当的 CORS
- **事件传递**：需要通过 postMessage 或直接访问 contentWindow
- **性能问题**：频繁的跨 iframe 通信会影响性能

### 3. 资源加载顺序
```javascript
// 必须按正确顺序加载
const vendors = [
  environment,    // 1. 先加载运行环境
  library,       // 2. 再加载组件库
  theme,         // 3. 然后加载主题
  simulatorUrl   // 4. 最后加载渲染器
];
```

### 4. 内存泄漏
- **事件监听器**：组件卸载时必须清理
- **iframe 引用**：切换文档时需要正确清理
- **循环引用**：Host 和 Renderer 之间避免循环引用

### 5. 状态同步
- **设计态和渲染态**：状态更新可能有延迟
- **多文档切换**：需要正确保存和恢复状态
- **异步问题**：许多操作是异步的，需要正确处理

## 六、优化建议

### 1. 简化场景下的层级合并
如果是简单的低代码场景，可以考虑：
- 合并 ProjectView 到 DesignerView
- 简化 HostView 的 UI 结构
- 但保留 Project、Host、Renderer 三个核心层

### 2. 性能优化
- **懒加载**：延迟加载非关键资源
- **缓存机制**：缓存组件库和渲染结果
- **批量更新**：批量处理 Schema 变更

### 3. 扩展性设计
- **插件化**：每一层都可以设计插件接口
- **主题定制**：支持自定义设备外观和主题
- **渲染器替换**：支持不同框架的渲染器

## 七、总结

这种多层架构设计虽然看起来复杂，但每一层都有其存在的合理性：

1. **Project 和 Host 是核心**，负责数据和运行时管理
2. **ProjectView 和 HostView 提供了 UI 灵活性**，支持复杂的视觉需求
3. **SimulatorRenderer 提供了运行时隔离**，确保安全和稳定

整体架构遵循了良好的设计原则，实现了关注点分离、高内聚低耦合的目标。虽然可以根据具体需求简化某些层级，但完整的架构为企业级低代码平台提供了必要的灵活性和扩展性。
